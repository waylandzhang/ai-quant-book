# 第 07 课：回测系统的陷阱

> **回测年化 100%，实盘亏损 50%。这不是意外，是必然。**

---

## 完美策略的覆灭

2019 年，一位量化研究员开发了一个"完美"的 A 股策略。

回测数据：
- 年化收益：120%
- 夏普比率：3.5
- 最大回撤：8%
- 胜率：68%

他信心满满地投入了 500 万人民币。

**第一个月**：收益 +2%，符合预期
**第二个月**：收益 -5%，开始不安
**第三个月**：收益 -8%，开始怀疑
**第六个月**：累计亏损 35%

他仔细检查了代码，发现三个致命错误：

1. **Look-Ahead Bias**：策略用了"第二天的开盘价"判断是否入场，但实际上第二天开盘前你不知道开盘价是多少

2. **过拟合**：他测试了 200 多个参数组合，选了最好的那个。但那只是"恰好在历史数据上表现好"，不是真正有效

3. **交易成本忽略**：回测假设滑点 0.1%，实盘滑点 0.5%；回测没算冲击成本，实盘大单经常被"吃"

**回测不是预测未来，而是描述过去。如果你不知道回测的陷阱，过去的描述就会变成对未来的误导。**

---

## 7.1 Look-Ahead Bias（前瞻偏差）

### 什么是 Look-Ahead Bias？

在回测中**使用了未来信息**做决策。

最常见的错误：

| 错误 | 说明 |
|-----|------|
| 用收盘价判断入场 | 收盘价是收盘后才知道的 |
| 用当日数据算指标 | 当日结束前，MACD 等指标是不确定的 |
| 用未来数据做标签 | "3 天后涨了"作为标签，但交易时你不知道 |

### 直观理解

```
时间线：
9:30 ─────── 10:00 ─────── 11:00 ─────── 收盘
  │            │            │            │
  你在这里     │            │         ← 你不知道这些信息
              │            ↑
              │         实时可知
              ↑
           实时可知
```

**回测时容易犯的错**：用收盘后的完整数据，假装在任意时刻做决策。

### 典型错误案例

```python
# 错误代码（Look-Ahead Bias）
for i in range(len(data)):
    if data['close'][i] > data['open'][i]:  # 今天收阳
        buy_price = data['open'][i]  # ← 错！你是收盘后才知道"收阳"的
        # 实际上开盘时你不知道今天会收阳还是收阴

# 正确代码
for i in range(1, len(data)):  # 从第二天开始
    if data['close'][i-1] > data['open'][i-1]:  # 昨天收阳
        buy_price = data['open'][i]  # 今天开盘价入场
```

### 如何避免？

| 原则 | 实现 |
|-----|------|
| **信号与执行分离** | T 日信号，T+1 日执行 |
| **只用过去数据** | 计算指标时用 `shift(1)` |
| **假设最坏成交价** | 买入用最高价，卖出用最低价 |

---

## 7.2 数据泄漏

### 什么是数据泄漏？

训练模型时，**测试集信息"泄漏"到了训练集**。

### 时间序列中的泄漏

金融数据有时间顺序，不能像普通 ML 那样随机划分：

```
错误的划分方式：
训练集: [1月, 3月, 5月, 7月, 9月, 11月]  ← 随机选
测试集: [2月, 4月, 6月, 8月, 10月, 12月]  ← 随机选

问题：训练集包含 3 月数据，但 2 月是测试集
      用"未来"数据训练，预测"过去"
```

**正确的划分**：

```
正确的划分方式：
训练集: [1月 - 8月]
验证集: [9月 - 10月]
测试集: [11月 - 12月]

保持时间顺序！
```

### 特征工程中的泄漏

| 泄漏类型 | 示例 |
|---------|------|
| **未来收益作为特征** | 用"未来 5 天收益"作为输入特征 |
| **全局归一化** | 用整个数据集的均值/标准差归一化 |
| **标签参与特征** | 用收益率计算的指标预测收益率 |

```python
# 错误：全局归一化（泄漏了未来数据的分布信息）
mean = df['close'].mean()  # 包含未来数据
std = df['close'].std()    # 包含未来数据
df['normalized'] = (df['close'] - mean) / std

# 正确：滚动窗口归一化
df['normalized'] = (df['close'] - df['close'].rolling(20).mean()) / df['close'].rolling(20).std()
```

### 特征重要性中的泄漏

如果一个特征的重要性极高（如 >50%），很可能是泄漏：

```
怀疑泄漏的信号：
- 某特征重要性 > 50%
- 模型准确率 > 90%
- 训练集和测试集表现一样好
```

---

## 7.3 过拟合

### 什么是过拟合？

模型"记住"了历史数据的噪音，而非学到真正的规律。

### 过拟合的表现

```
训练集表现：年化 80%，夏普 3.0
测试集表现：年化 5%，夏普 0.5

巨大的差距 = 过拟合
```

### 为什么量化特别容易过拟合？

| 原因 | 说明 |
|-----|------|
| **参数太多** | 100 个参数，只有 1000 个样本 |
| **多重检验** | 测试 1000 个策略，总有几个"有效" |
| **信噪比低** | 市场噪音大，真实信号弱 |
| **分布不稳定** | 过去的规律未来可能失效 |

### 多重检验问题

假设你测试 100 个随机策略（实际上都无效）：

```
p < 0.05 的概率：5%
100 个策略中，期望有 5 个"显著"

问题：这 5 个策略看起来有效，但只是运气好
```

**Bonferroni 校正**：如果测试 n 个策略，显著性阈值应该是 0.05/n

```
测试 100 个策略 → 阈值 0.05/100 = 0.0005
测试 1000 个策略 → 阈值 0.05/1000 = 0.00005
```

### 过拟合的检测

| 指标 | 过拟合信号 |
|-----|-----------|
| 训练/测试差距 | 训练 >> 测试 |
| 参数敏感性 | 微调参数，结果剧变 |
| 跨时期稳定性 | 不同年份表现差异大 |
| 策略复杂度 | 规则越复杂，越可能过拟合 |

### 如何减少过拟合？

| 方法 | 说明 |
|-----|------|
| **简化模型** | 越简单越不容易过拟合 |
| **增加数据** | 更多样本，更难记住噪音 |
| **正则化** | L1/L2 惩罚复杂模型 |
| **早停** | 验证集表现下降时停止训练 |
| **集成方法** | 多个模型投票，减少个体偏差 |

---

## 7.4 交易成本忽略

### 常被忽略的成本

| 成本类型 | 典型值（2024-2025）| 回测常见假设 |
|---------|-------|-------------|
| **手续费** | 美股零佣金（零售）；A股万1-万2.5 | 0% 或低估 |
| **滑点** | 0.01-0.5%（视流动性）| 0% 或固定值 |
| **市场冲击** | 0.1-1%+ | 完全忽略 |
| **借券费用** | 年化 0.5-50%+（视难借程度）| 忽略 |
| **资金成本** | 年化 4-5%（当前利率环境）| 忽略 |

> **美股"零佣金"注意**：虽然主流券商（Fidelity、Schwab、Robinhood）免佣金，但仍有 SEC 费（费率会调整，量级为每卖出 $1M 数十美元）和 PFOF（订单流支付）等隐性成本。

### 滑点的真实影响

假设策略每年交易 200 次，单边滑点 0.2%：

```
年交易成本 = 200次 × 0.2% × 2（买+卖）= 80%

如果你的策略年化收益是 50%，扣除滑点后：
实际收益 = 50% - 80% = -30%
```

**高频策略被滑点杀死是常态**。

### 市场冲击建模

大单会"吃掉"订单簿，抬高/压低成交价：

```
平方根法则估算：

冲击成本 ≈ σ × √(Q/V)

σ = 日波动率（如 2%）
Q = 你的订单量
V = 日均成交量

示例：
订单量 = 日均成交量的 1%
冲击成本 ≈ 2% × √0.01 = 0.2%
```

### 正确的成本建模

```python
def estimate_trading_cost(
    price: float,
    quantity: float,
    daily_volume: float,
    daily_volatility: float,
    commission_rate: float = 0.0003  # 万三
) -> dict:
    """估算交易成本"""

    # 手续费
    commission = price * quantity * commission_rate

    # 滑点（假设市价单吃掉 2-3 档）
    slippage_rate = 0.001 * (quantity / daily_volume) ** 0.5
    slippage = price * quantity * slippage_rate

    # 市场冲击
    participation = quantity / daily_volume
    impact_rate = daily_volatility * (participation ** 0.5)
    market_impact = price * quantity * impact_rate

    total = commission + slippage + market_impact

    return {
        'commission': commission,
        'slippage': slippage,
        'market_impact': market_impact,
        'total': total,
        'total_rate': total / (price * quantity)
    }
```

---

## 7.5 正确的回测方法

### Walk-Forward 验证

**核心思想**：模拟真实的策略开发过程——用过去训练，在"未来"测试，滚动前进。

```
第 1 轮：
  训练: [1月-6月]  →  测试: [7月]
第 2 轮：
  训练: [2月-7月]  →  测试: [8月]
第 3 轮：
  训练: [3月-8月]  →  测试: [9月]
...

每轮都是"样本外"测试
```

**优点**：
- 模拟真实情况
- 多次样本外测试，结果更可靠
- 能检测参数稳定性

### Out-of-Sample 测试

**严格保留一部分数据，完全不参与开发**：

```
开发阶段可用数据：[2015-2022]
  ├─ 训练集: [2015-2019]
  ├─ 验证集: [2020-2021]
  └─ 调参、选模型都在这里完成

最终测试数据：[2022-2023]
  └─ 只用一次！
     一旦看过，就不再是 OOS
```

**关键原则**：OOS 数据只能用一次。如果你根据 OOS 结果调整策略，它就变成了 IS（样本内）。

### Monte Carlo 模拟

**通过随机扰动，测试策略的鲁棒性**：

```
原始回测：年化 30%

Monte Carlo 模拟（1000 次）：
- 随机打乱交易顺序
- 随机调整入场时间 ±1 天
- 随机调整成本 ±20%

结果分布：
  5th percentile: 年化 8%
  50th percentile: 年化 25%
  95th percentile: 年化 45%

→ 真实表现可能在 8%-45% 之间
```

**如果 Monte Carlo 后大部分情况都亏损，策略不可靠**。

### 回测质量门（Quality Gate）

> **这是全书最重要的清单之一。** 在开始实盘前，每一项都必须通过。打印出来贴在墙上。

#### 第一层：数据完整性

| # | 检查项 | 通过标准 | 失败后果 |
|---|-------|---------|---------|
| 1.1 | 数据覆盖 | 训练+测试 ≥ 5 年，包含至少 1 次牛熊周期 | 未经历极端市场，策略稳定性未知 |
| 1.2 | 复权/换月处理 | 使用后复权价格，期货主力连续 | 假信号、收益虚高 |
| 1.3 | 幸存者偏差 | 包含退市股票数据 | 高估历史收益 50%+ |
| 1.4 | 时区对齐 | 所有数据源统一时区（UTC 或本地） | 跨市场信号错乱 |

#### 第二层：时间完整性

| # | 检查项 | 通过标准 | 失败后果 |
|---|-------|---------|---------|
| 2.1 | Look-Ahead Bias | 信号 T 日生成，T+1 日执行 | 回测收益虚高 2-10x |
| 2.2 | 数据泄漏 | 训练/测试严格按时间分离 | 过拟合不可检测 |
| 2.3 | 特征计算 | 所有特征用 shift(1) 或更早数据 | 用了未来信息 |
| 2.4 | 标签定义 | 标签只用当前时刻之前的数据 | 标签泄漏 |

#### 第三层：过拟合检测

| # | 检查项 | 通过标准 | 失败后果 |
|---|-------|---------|---------|
| 3.1 | OOS 表现 | OOS 收益 > 训练收益的 50% | 严重过拟合 |
| 3.2 | 参数稳定性 | 参数 ±20% 变化，收益变化 < 30% | 参数敏感，不可复现 |
| 3.3 | 多重检验 | 测试 n 个策略，p 值阈值 = 0.05/n | 假阳性策略 |
| 3.4 | 跨时期稳定性 | 每年夏普 > 0.5，无大幅波动 | 只在特定时期有效 |

#### 第四层：成本建模

| # | 检查项 | 通过标准 | 失败后果 |
|---|-------|---------|---------|
| 4.1 | 手续费 | 包含真实费率（美股零售零佣金，机构约$0.003/股；A股约万二） | 低估成本 |
| 4.2 | 滑点 | 保守假设（建议 0.1-0.3%） | 高频策略亏损 |
| 4.3 | 市场冲击 | 大单考虑平方根冲击模型 | 容量虚高 |
| 4.4 | 资金成本 | 融资做空考虑借券费用 | 做空策略盈利虚高 |

#### 第五层：验证方法

| # | 检查项 | 通过标准 | 失败后果 |
|---|-------|---------|---------|
| 5.1 | Walk-Forward | 至少 10 轮滚动验证 | 单次验证不可靠 |
| 5.2 | Monte Carlo | 90% 模拟结果 > 0 | 运气成分太大 |
| 5.3 | 压力测试 | 2008、2020、2022 三次危机都测试 | 危机时爆仓 |
| 5.4 | 收益衰减 | 回测收益 × 0.5 后仍可接受 | 实盘预期过高 |

**使用方法**：
1. 每项必须通过，任一项失败则不可实盘
2. 通过的项打 ✅，失败的项标注具体问题
3. 修复后重新运行整个检查流程

**快速自检**（在每次回测后问自己）：
- "我用了未来信息吗？" → 检查层 2
- "换个时期还有效吗？" → 检查层 3
- "成本扣掉还赚钱吗？" → 检查层 4
- "运气成分大吗？" → 检查层 5

---

## 7.6 常见误区

**误区一：回测收益高就是好策略**

最危险的假设。回测收益高可能是过拟合、Look-Ahead Bias、成本低估的结果。真正重要的是 OOS（样本外）表现和参数稳定性。

**误区二：测试了 100 个策略，选最好的那个**

典型的多重检验问题。测试 100 个随机策略，期望有 5 个"显著"（p<0.05），但它们只是运气好。正确做法：p 值阈值 = 0.05/100 = 0.0005。

**误区三：回测用收盘价成交是合理假设**

不合理。收盘价是收盘后才知道的。实际交易中，你在收盘前下单，成交价可能是收盘价 ± 滑点。正确做法：信号 T 日生成，T+1 日执行。

**误区四：模拟交易表现好就能实盘**

不够。模拟交易通常滑点理想、无市场冲击、100% 成交。实盘需要渐进部署：模拟交易 → 1-5% 资金实盘 → 逐步加仓。

---

## 7.7 从回测到实盘的差距

> **行业共识**：回测到实盘的性能衰减平均为 **30-50%**。这不是悲观估计，而是无数实盘验证后的行业经验。

### 为什么实盘总是比回测差？

| 因素 | 回测 | 实盘 | 收益影响 |
|-----|------|------|---------|
| 成交价 | 收盘价或假设价 | 实际成交价（通常更差）| -5~20% |
| 滑点 | 固定假设（0.1%）| 随市场变化（0.2-0.5%）| -10~30% |
| 市场冲击 | 完全忽略 | 大单显著抬高成本 | -5~50% |
| 成交量 | 假设 100% 成交 | 可能部分成交 | -5~15% |
| 延迟 | 忽略 | 50-500ms | -2~10% |
| 故障 | 不存在 | 网络断、API 错误 | 不可预测 |
| 心理因素 | 不存在 | 恐惧和贪婪 | 不可预测 |
| 模型过拟合 | 不可见 | 暴露 | -20~80% |

### 性能衰减的行业数据

根据多家量化机构的实盘跟踪统计：

```
┌─────────────────────────────────────────────────────────┐
│                回测到实盘性能衰减分布                      │
├─────────────────────────────────────────────────────────┤
│  衰减幅度        │  占比    │  主要原因                   │
├─────────────────────────────────────────────────────────┤
│  < 20%          │  10%    │  低频策略、优秀成本建模       │
│  20-30%         │  25%    │  正常衰减范围                │
│  30-50%         │  40%    │  典型情况（行业均值）         │
│  50-70%         │  15%    │  成本低估、轻度过拟合         │
│  > 70%          │  10%    │  严重过拟合、成本严重低估      │
└─────────────────────────────────────────────────────────┘
```

**关键洞察**：如果你的策略在回测中收益惊人（年化>100%），几乎可以肯定实盘会大打折扣。

### 预期收益衰减公式

**保守估计法**（推荐）：

```
实盘预期收益 = 回测收益 × 0.5 - 隐性成本

隐性成本包括：
- 数据滞后：-2~5%
- 执行差异：-3~10%
- 模型衰减：-5~15%
```

**分场景估计**：

| 策略类型 | 回测年化 | 乐观预期 | 保守预期 | 衰减因子 |
|---------|---------|---------|---------|---------|
| 低频价值 | 30% | 20% | 12% | 0.4-0.65 |
| 中频动量 | 50% | 30% | 18% | 0.35-0.6 |
| 高频做市 | 100% | 40% | 20% | 0.2-0.4 |
| ML因子 | 80% | 35% | 15% | 0.2-0.45 |

**核心原则**：**如果回测收益减半后仍然可接受，再考虑实盘**。

### 衰减的主要原因分解

```
回测收益 100%
    │
    ├── 交易成本低估 ────────────────────── -20%
    │     • 滑点假设 0.1%，实际 0.3%
    │     • 忽略市场冲击
    │
    ├── 过拟合 ─────────────────────────── -25%
    │     • 参数在历史数据上过度优化
    │     • 多重检验未校正
    │
    ├── 执行差异 ───────────────────────── -10%
    │     • 延迟导致价格偏移
    │     • 部分成交影响策略逻辑
    │
    ├── 市场regime变化 ─────────────────── -10%
    │     • 历史模式不再有效
    │     • 新的市场参与者结构
    │
    └── 实盘预期收益 ─────────────────────  35%
```

### 渐进式部署

| 阶段 | 资金规模 | 目标 |
|-----|---------|------|
| **Paper Trading** | $0 | 验证系统稳定性 |
| **微量实盘** | 1-5% 总资金 | 验证执行质量 |
| **小规模实盘** | 10-20% | 积累实盘数据 |
| **正常运行** | 计划规模 | 持续监控 |

---

## 7.8 多智能体视角

### 回测系统的 Agent 分工

![回测智能体流程](assets/backtest-agent-flow.svg)

### 为什么需要独立的 Validation Agent？

- **策略开发者有偏见**：总想证明自己的策略有效
- **自动检测更可靠**：不会遗漏检查项
- **标准化流程**：确保每个策略都经过同样的审核

---

## 💻 代码实现（可选）

### Walk-Forward 验证框架

```python
import pandas as pd
import numpy as np
from typing import Callable, List, Dict

def walk_forward_validation(
    data: pd.DataFrame,
    strategy_fn: Callable,
    train_window: int = 252,  # 约 1 年
    test_window: int = 63,    # 约 3 个月
    step: int = 21            # 每月滚动一次
) -> List[Dict]:
    """
    Walk-Forward 验证

    参数：
    - data: 包含价格数据的 DataFrame
    - strategy_fn: 策略函数，接收训练数据，返回模型/参数
    - train_window: 训练窗口大小（天数）
    - test_window: 测试窗口大小（天数）
    - step: 滚动步长（天数）

    返回：
    - 每轮测试的结果列表
    """
    results = []
    total_len = len(data)

    for start in range(0, total_len - train_window - test_window, step):
        train_end = start + train_window
        test_end = train_end + test_window

        train_data = data.iloc[start:train_end]
        test_data = data.iloc[train_end:test_end]

        # 在训练集上训练/优化
        model = strategy_fn(train_data)

        # 在测试集上评估
        test_returns = evaluate_strategy(model, test_data)

        results.append({
            'train_start': train_data.index[0],
            'train_end': train_data.index[-1],
            'test_start': test_data.index[0],
            'test_end': test_data.index[-1],
            'test_return': test_returns.sum(),
            'test_sharpe': calculate_sharpe(test_returns)
        })

    return results


def detect_look_ahead_bias(backtest_fn: Callable, data: pd.DataFrame) -> bool:
    """
    检测 Look-Ahead Bias

    原理：如果用未来数据，交易时间应该和信号时间匹配不上
    """
    trades = backtest_fn(data)

    for trade in trades:
        signal_time = trade['signal_time']
        execution_time = trade['execution_time']

        # 信号时间应该 < 执行时间
        if signal_time >= execution_time:
            print(f"可能存在 Look-Ahead Bias: 信号时间 {signal_time} >= 执行时间 {execution_time}")
            return True

    return False


def monte_carlo_backtest(
    base_results: pd.Series,
    n_simulations: int = 1000,
    return_perturbation: float = 0.1
) -> Dict:
    """
    Monte Carlo 模拟

    参数：
    - base_results: 原始回测的逐日收益
    - n_simulations: 模拟次数
    - return_perturbation: 收益扰动幅度

    返回：
    - 模拟结果统计
    """
    simulated_returns = []

    for _ in range(n_simulations):
        # 随机打乱顺序 + 添加噪音
        shuffled = base_results.sample(frac=1, replace=False)
        noisy = shuffled * (1 + np.random.uniform(-return_perturbation, return_perturbation, len(shuffled)))
        total_return = (1 + noisy).prod() - 1
        simulated_returns.append(total_return)

    simulated_returns = np.array(simulated_returns)

    return {
        'mean': simulated_returns.mean(),
        'std': simulated_returns.std(),
        'percentile_5': np.percentile(simulated_returns, 5),
        'percentile_50': np.percentile(simulated_returns, 50),
        'percentile_95': np.percentile(simulated_returns, 95),
        'prob_positive': (simulated_returns > 0).mean()
    }
```

---

## 本课交付物

完成本课后，你将获得：

1. **对回测陷阱的深刻认知** - 知道为什么回测赚钱、实盘亏钱
2. **偏差检测能力** - 能识别 Look-Ahead Bias 和数据泄漏
3. **正确的回测方法论** - Walk-Forward、OOS、Monte Carlo
4. **实盘预期管理** - 理解回测到实盘的收益衰减
5. **回测质量门清单** - 可复用的 20 项检查标准

### ✅ 验收标准

| 检查项 | 验收标准 | 自测方法 |
|-------|---------|---------|
| **Look-Ahead 检测** | 能在代码中识别前瞻偏差 | 给定代码片段，指出使用未来数据的位置 |
| **数据划分** | 能正确划分训练/验证/测试集 | 给定 5 年数据，画出时间分割图 |
| **过拟合识别** | 能说出 3 个过拟合信号 | 不看笔记，列举检测指标 |
| **Quality Gate** | 能默写 20 项检查的核心标准 | 从头填写检查清单 |

**📝 诊断练习**：

某策略回测结果如下，诊断可能的问题：
- 训练集年化收益：85%
- 测试集年化收益：12%
- 参数微调 ±10% 后收益变化 50-200%
- 共测试了 150 个策略变体
- 只有 2018-2022 年数据

<details>
<summary>点击查看诊断结果</summary>

**问题诊断**：

1. **严重过拟合** - 训练 85% vs 测试 12%，差距 7 倍，远超 50% 阈值
2. **参数敏感** - ±10% 变化导致 50-200% 收益变化，不满足稳定性要求
3. **多重检验问题** - 150 个变体，p 值阈值应为 0.05/150 = 0.00033
4. **数据不足** - 4 年数据未覆盖 2008、2020 危机，稳定性未知

**结论**：此策略不可实盘。需要：
- 简化模型减少参数
- 获取更长时间数据（至少 10 年）
- 应用 Bonferroni 校正筛选策略
- 进行 Walk-Forward 和 Monte Carlo 验证

</details>

---

## 本课要点回顾

- [x] 理解 Look-Ahead Bias 的本质和检测方法
- [x] 掌握时间序列数据划分的正确方式，避免数据泄漏
- [x] 认识过拟合的危害和多重检验问题
- [x] 学会正确建模交易成本
- [x] 掌握 Walk-Forward、OOS、Monte Carlo 等验证方法

---

## 延伸阅读

- [背景知识：历史著名量化事故](../Part1-快速体验/背景知识/历史著名量化事故.md) - 回测失败的真实案例
- [背景知识：夏普比率的统计陷阱](背景知识/夏普比率的统计陷阱.md) - 多重检验与 Deflated Sharpe Ratio
- [背景知识：Tick 级回测框架](背景知识/Tick级回测框架.md) - 高精度回测与队列位置模拟
- *Advances in Financial Machine Learning* - Chapter 12: Backtesting

---

## Part 2（截至第 07 课）小结

到这里，你已经把量化基础里最容易踩坑的两座大山（数据、回测）拆开了。

截至第 07 课，你学到了：

| 课程 | 核心收获 |
|-----|---------|
| 第 02 课 | 市场结构、交易成本、策略生命周期 |
| 第 03 课 | 时间序列、收益率、风险度量、厚尾分布 |
| 第 04 课 | 技术指标的本质是特征工程，不是买卖信号 |
| 第 05 课 | 趋势跟随 vs 均值回归，策略选择取决于市场状态 |
| 第 06 课 | 数据工程的挑战：API、时区、质量、偏差 |
| 第 07 课 | 回测陷阱和正确的验证方法 |

## 下一课预告

**第 08 课：Beta、对冲与市场中性**

你的策略赚钱了，但这些钱是从哪里来的？是你的 Alpha（真正的超额收益），还是只是跟着市场涨了（Beta）？下一课我们深入理解风险的来源，学会如何分解收益、如何对冲，以及为什么散户很难做真正的市场中性。
